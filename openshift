jumpserver
Cluster
projects,namespaces 

-namespace = Kubernetes term (technical, basic)
Project = OpenShift term (namespace + extras)
Every project is backed by a namespace
They look the same, but OpenShift adds user access, UI info, metadata
pods - have one/more containers


1: Containerize Applications¶
1.1: Environment Overview¶
Your lab environment is hosted on our cloud environment. The appropriate kubernetes related tools (docker, kubectl, kubernetes, etc.) have already been installed ahead of time.
1.2: Prepare Your Lab¶
Step 1: Kubernetes and your Docker Registry¶
There should be a registry running that we will push our images to:
echo $REGISTRY_HOST
1.3: Build Docker image for your frontend application¶
Step 1: Download the gowebapp code under your home directory and untar the file¶
cd $HOME && curl -s http://$WORKSHOP_NAMESPACE-files/_static/lab-files.tar.gz | tar -xzv
Step 2: Write Dockerfile for your frontend application¶
cd $HOME/gowebapp/gowebapp
Create a file named Dockerfile in this directory for the frontend Go application. Use vi or any preferred text editor. The template below provides a starting point for defining the contents of this file.
Note
Replace TODO comments with the appropriate commands
Dockerfile-gowebapp
	#TODO --- Define this image to inherit from the "ubuntu" base image and version "impish"
#https://hub.docker.com/_/ubuntu
#https://docs.docker.com/engine/reference/builder/#from

EXPOSE 8080
USER 1000

#TODO --- Copy source code in the ./code directory into /opt/gowebapp
#https://docs.docker.com/engine/reference/builder/#copy

#TODO --- Copy the application config in the ./config directory into 
#/opt/gowebapp/config

WORKDIR /opt/gowebapp/

#TODO --- Define an entrypoint for this image which executes the gowebapp 
#application (/opt/gowebapp/gowebapp) when the container starts
#https://docs.docker.com/engine/reference/builder/#entrypoint

Step 3: Build gowebapp Docker image locally¶
cd $HOME/gowebapp/gowebapp
Build the gowebapp image locally. Make sure to include “.“ at the end. Make sure the build runs to completion without errors. You should get a success message.
docker build -t gowebapp:v1 .
1.4: Build Docker image for your backend application¶
Step 1: Write Dockerfile for your backend application¶
cd $HOME/gowebapp/gowebapp-mysql
Create a file named Dockerfile in this directory for the backend MySQL database application. Use vi or any preferred text editor. The template below provides a starting point for defining the contents of this file.
Note
Replace TODO comments with the appropriate commands
Dockerfile-gowebapp-mysql
	#TODO --- Define this image to inherit from the "mysql" version 5.6 base image
#https://hub.docker.com/_/mysql/
#https://docs.docker.com/engine/reference/builder/#from

USER 1000

#TODO --- Investigate the "Initializing a Fresh Instance" instructions for the mysql 
#parent image, and copy the local gowebapp.sql file to the proper container directory 
#to be automatically executed when the container starts up 
#https://hub.docker.com/_/mysql/
#https://docs.docker.com/engine/reference/builder/#copy

Step 2: Build gowebapp-mysql Docker image locally¶
cd $HOME/gowebapp/gowebapp-mysql
Build the gowebapp-mysql image locally. Make sure to include “.“ at the end. Make sure the build runs to completion without errors. You should get a success message.
docker build -t gowebapp-mysql:v1 .
1.5: Run and test Docker images locally¶
Before deploying to Kubernetes, let’s run and test the Docker images locally, to ensure that the frontend and backend containers run and integrate properly.
Step 1: Create Docker user-defined network¶
To facilitate cross-container communication, let’s first define a user-defined network in which to run the frontend and backend containers:
docker network create gowebapp
Step 2: Launch frontend and backend containers¶
Next, let’s launch a frontend and backend container using the Docker CLI.
First, we launch the database container, as it will take a bit longer to startup, and the frontend container depends on it. Notice how we are injecting the database password into the MySQL configuration as an environment variable:
docker run --net gowebapp --name gowebapp-mysql --hostname gowebapp-mysql -d -e MYSQL_ROOT_PASSWORD=mypassword gowebapp-mysql:v1
Warning
Wait at least 20 seconds after starting the backend before attempting to start the frontend. Right now, the frontend will crash if the backend is not ready.
Now launch a frontend container, mapping the container port 8080 - where the web application is exposed - to port 9000 on the host machine:
docker run -p 9000:8080 --net gowebapp -d --name gowebapp --hostname gowebapp gowebapp:v1
Step 3: Test the application locally¶
Now that we’ve launched the application containers, let’s try to test the web application locally.
You should be able to access the application by running the following command in the terminal and then clicking the URL it produces.
echo "http://$SESSION_NAME-gowebapp-docker.$INGRESS_DOMAIN"
Create an account and login. Write something on your Notepad and save it. This will verify that the application is working and properly integrates with the backend database container.
Step 4: Inspect the MySQL database¶
Let’s connect to the backend MySQL database container and run some queries to ensure that application persistence is working properly:
docker exec -it gowebapp-mysql mysql -u root -pmypassword gowebapp
Once connected, run some simple SQL commands to inspect the database tables and persistence:
#Simple SQL to navigate
SHOW DATABASES;
USE gowebapp;
SHOW TABLES;
SELECT * FROM <table_name>;
exit;
Step 5: Cleanup application containers¶
When we’re finished testing, we can terminate and remove the currently running frontend and backend containers from our local machine:
docker rm -f gowebapp gowebapp-mysql
1.6: Create and push Docker images to Docker registry¶
Step 1: Tag images to target another registry¶
We are finished testing our images. We now need to push our images to an image registry so our Kubernetes cluster can access them. First, we need to tag our Docker images to use the registry in your lab environment:
docker tag gowebapp:v1 $REGISTRY_HOST/gowebapp:v1

docker tag gowebapp-mysql:v1 $REGISTRY_HOST/gowebapp-mysql:v1
Step 2: publish images to the registry¶
docker push $REGISTRY_HOST/gowebapp:v1
docker push $REGISTRY_HOST/gowebapp-mysql:v1
1.7: Conclusion¶
Congratulations! By containerizing your application components, you have taken the first important step toward deploying your application to Kubernetes.
Solutions¶
If you’re stuck, check out the solutions for this lab.
________________________________________
© Copyright 2022, VMware, Inc..
Built with Sphinx using a theme provided by Read the Docs.
